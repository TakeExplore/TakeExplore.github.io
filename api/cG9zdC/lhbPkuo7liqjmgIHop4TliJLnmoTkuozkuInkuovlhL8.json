{"title":"关于动态规划的二三事儿","date":"2019-03-15T11:56:50.355Z","slug":"关于动态规划的二三事儿","tags":["数据结构"],"categories":["数据结构"],"updated":"2019-03-22T10:13:22.932Z","content":"<p>昨晚看了一下动态规划的经典案例，但是单单能看明白也不行鸭。会写才是真本事，于是抄家伙开始在leetcode上从最简单的刷起来。</p>\n<h3 id=\"最大子序和\"><a href=\"#最大子序和\" class=\"headerlink\" title=\"最大子序和\"></a>最大子序和</h3><h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<blockquote>\n<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>\n</blockquote>\n<h4 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h4><p>求最大子序和就是不断比较<strong>当前数</strong>和<strong>当前数加上前面序列的最大和</strong>的大小，如果小于，则说明为递增的，把当前和赋值给前面序列的最大和。</p>\n<p>公式为:f(n) = max { nums[n] , nums[n] + f(n-1) }</p>\n<p>转换为js代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var maxSubArray = function(nums) &#123;</span><br><span class=\"line\">    var temp = 0</span><br><span class=\"line\">    var count = nums[0]</span><br><span class=\"line\">    for(var i = 0; i &lt; nums.length;i++)&#123;</span><br><span class=\"line\">        if(nums[i] + temp &gt; nums[i])&#123;</span><br><span class=\"line\">            temp = nums[i]+temp</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            temp = nums[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(temp &gt; count)&#123;  //如果当前子序列和大于之前的和，则赋值</span><br><span class=\"line\">            count = temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样就轻松实现了时间复杂度为o(n)</p>\n<p>(题目进阶版为分治法，目前还没有找到解决方法哦，会继续学习的)</p>\n<h3 id=\"买卖股票的最佳时机Ⅰ\"><a href=\"#买卖股票的最佳时机Ⅰ\" class=\"headerlink\" title=\"买卖股票的最佳时机Ⅰ\"></a>买卖股票的最佳时机Ⅰ</h3><h4 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。</p>\n<blockquote>\n<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>\n</blockquote>\n<h4 id=\"算法思路-1\"><a href=\"#算法思路-1\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h4><p>不断比较<strong>前一天的最大利润</strong>和<strong>当天股票价格减去前一段时间的最低购入价格</strong>的大小，取其中最大值，既可以得出能获取的最大利润。</p>\n<p>获得公式：f(n) = max { f(n-1),num[n] - min}</p>\n<p>转换为js代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var maxProfit = function(prices) &#123;</span><br><span class=\"line\">    var min = prices[0]</span><br><span class=\"line\">    var count = 0//获取的最大利益</span><br><span class=\"line\">    if(prices.length === 0)&#123;</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(var i = 0 ;i &lt;= prices.length;i++)&#123;</span><br><span class=\"line\">        if(prices[i] &lt; min)&#123;</span><br><span class=\"line\">            min = prices[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(prices[i] - min &gt; count)&#123;//大小判断</span><br><span class=\"line\">            count = prices[i] - min</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"js 基本排序算法总结","slug":"js 基本算法总结"},"next":{"title":"第二次面试经验总结","slug":"第二次面试经验总结"},"link":"http://yoursite.com/post/关于动态规划的二三事儿/","copyright":{"custom":"飞过人间的无常 才懂爱才是宝藏"}}