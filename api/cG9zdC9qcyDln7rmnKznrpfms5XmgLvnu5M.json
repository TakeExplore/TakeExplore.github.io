{"title":"","date":"2019-03-22T10:05:00.918Z","slug":"js 基本算法总结","updated":"2019-03-22T10:09:59.149Z","content":"<h1 id=\"js-基本算法总结\"><a href=\"#js-基本算法总结\" class=\"headerlink\" title=\"js 基本算法总结\"></a>js 基本算法总结</h1><p>标签（空格分隔）： leetcode</p>\n<hr>\n<p>最近在疯狂刷算法题，同时也在补习之前落下或者忘记的很多数据结构。另开一篇文章来记录一些常用数据结构或者算法js的写法。</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>这算是排序算法中时间复杂度比较低的算法了吧。之前上课时觉得很难理解，看了阮一峰老师的文章，感觉很快就明白了。</p>\n<p>老师讲的很详细，我就大致用自己的话总结一下。</p>\n<ol>\n<li>选取一个中间值temp作为比较的基准 （也就是parseInt(arr.length/2)</li>\n<li>循环比较，创建两个数组right,left。若比temp大则放到右边，push到right中，反之放到左边，push到left中。</li>\n<li>递归循环进行上面两步，就可以得到一个排好的数组。</li>\n</ol>\n<p>实现代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var quickSort = function(arr) &#123;</span><br><span class=\"line\">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class=\"line\">　　var index = Math.floor(arr.length / 2);</span><br><span class=\"line\">　　var temp = arr.splice(index, 1)[0];</span><br><span class=\"line\">　　var left = [];</span><br><span class=\"line\">　　var right = [];</span><br><span class=\"line\">　　for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">　　　　if (arr[i] &lt; temp) &#123;</span><br><span class=\"line\">　　　　　　left.push(arr[i]);</span><br><span class=\"line\">　　　　&#125; else &#123;</span><br><span class=\"line\">　　　　　　right.push(arr[i]);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　return quickSort(left).concat([temp], quickSort(right));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>另外：<br>js有一个可直接用的api sort()，默认排序顺序是根据字符串Unicode码点。<br>具体使用方法：<a href=\"https://segmentfault.com/a/1190000000410506\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000000410506</a></p>\n<p>时间复杂度：<br>附上链接：<a href=\"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html</a></p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"深度-amp-广度优先遍历\"><a href=\"#深度-amp-广度优先遍历\" class=\"headerlink\" title=\"深度&amp;广度优先遍历\"></a>深度&amp;广度优先遍历</h3>","next":{"title":"关于动态规划的二三事儿","slug":"关于动态规划的二三事儿"},"link":"http://yoursite.com/post/js 基本算法总结/","toc":[{"title":"js 基本算法总结","id":"js-基本算法总结","index":"1","children":[{"title":"排序","id":"排序","index":"1.1","children":[{"title":"快速排序","id":"快速排序","index":"1.1.1"}]},{"title":"树","id":"树","index":"1.2","children":[{"title":"深度&amp;广度优先遍历","id":"深度-amp-广度优先遍历","index":"1.2.1"}]}]}],"copyright":{"custom":"飞过人间的无常 才懂爱才是宝藏"}}