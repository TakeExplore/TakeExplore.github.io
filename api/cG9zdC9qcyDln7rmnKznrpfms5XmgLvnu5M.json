{"title":"js 基本排序算法总结","date":"2019-03-22T10:05:00.918Z","slug":"js 基本算法总结","tags":["数据结构"],"categories":["数据结构"],"updated":"2019-04-12T08:03:55.022Z","content":"<p>最近在疯狂刷算法题，同时也在补习之前落下或者忘记的很多数据结构。另开一篇文章来记录一些常用js排序算法的写法。</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>这算是排序算法中时间复杂度比较低的算法了吧。之前上课时觉得很难理解，看了阮一峰老师的文章，感觉很快就明白了。</p>\n<p>老师讲的很详细，我就大致用自己的话总结一下。</p>\n<ol>\n<li>选取一个中间值temp作为比较的基准 （也就是parseInt(arr.length/2)</li>\n<li>循环比较，创建两个数组right,left。若比temp大则放到右边，push到right中，反之放到左边，push到left中。</li>\n<li>递归循环进行上面两步，就可以得到一个排好的数组。</li>\n</ol>\n<p>实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var quickSort = function(arr) &#123;</span><br><span class=\"line\">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class=\"line\">　　var index = Math.floor(arr.length / 2);</span><br><span class=\"line\">　　var temp = arr.splice(index, 1)[0];</span><br><span class=\"line\">　　var left = [];</span><br><span class=\"line\">　　var right = [];</span><br><span class=\"line\">　　for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">　　　　if (arr[i] &lt; temp) &#123;</span><br><span class=\"line\">　　　　　　left.push(arr[i]);</span><br><span class=\"line\">　　　　&#125; else &#123;</span><br><span class=\"line\">　　　　　　right.push(arr[i]);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　return quickSort(left).concat([temp], quickSort(right));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>另外：<br>js有一个可直接用的api sort()，默认排序顺序是根据字符串Unicode码点。<br>具体使用方法：<a href=\"https://segmentfault.com/a/1190000000410506\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000000410506</a></p>\n<p>时间复杂度：<br>最好：o(nlogn)<br>最差：o(n^2)<br>平均：o(nlogn)<br>附上链接：<a href=\"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html</a></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>无论什么数据都为 o(n^2) 稳定</p>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>在序列中找到最小（大）的数，放在排序序列的起始位置，在剩余的序列中继续寻找最小（大）数，放到已排序列的末尾。以此内推，直到最后一个数结束排序。</p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function selectionSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    var minIndex, temp;</span><br><span class=\"line\">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class=\"line\">        minIndex = i;</span><br><span class=\"line\">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class=\"line\">                minIndex = j;                 //将最小数的索引保存</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[minIndex];</span><br><span class=\"line\">        arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><h4 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>最好情况：o(n)<br>最坏情况：o(n^2)<br>平均情况：o(n^2）</p>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>（升序）<br>从第二个数开始，分别与前面的数进行比较。找到第一个小于该数的数，插入到其后面（不断和前一位交换位置直到交换到该值后面）。以此类推，到最后一个数结束。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function binaryInsertionSort(array) &#123;</span><br><span class=\"line\">    for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            var key = array[i];//保存该值</span><br><span class=\"line\">            var j = i - 1;</span><br><span class=\"line\">            while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;</span><br><span class=\"line\">                array[j + 1] = array[j];//不断交换位置，直到有数小于key时，停止交换</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[j + 1] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h4><p>在有序数组中寻找某一特定元素，从数组中间开始，如果正好是要查的元素则结束。如果某一特定元素大于或者小于中间元素，则在对应的那一半中查找。并且一样从中间开始比较。</p>\n<p>改进后的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function binaryInsertionSort(array) &#123;</span><br><span class=\"line\">     for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            var key = array[i], left = 0, right = i - 1;//保证是在前面的有序数组中查找</span><br><span class=\"line\">            while (left &lt;= right) &#123;</span><br><span class=\"line\">                var middle = parseInt((left + right) / 2);</span><br><span class=\"line\">                if (key &lt; array[middle]) &#123;</span><br><span class=\"line\">                    right = middle - 1;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    left = middle + 1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (var j = i - 1; j &gt;= left; j--) &#123;</span><br><span class=\"line\">                array[j + 1] = array[j];//向后移位置</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[left] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><h4 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>最好情况：o(nlog^2 n)<br>最坏情况：o(nlog^2 n)<br>平均情况：o(nlogn)</p>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>递减增量排序算法（不稳定）<br>把整个排序的序列分割成若干子序列分别进行插入排序，待整个序列中的记录基本有序时，再对全体记录进行直接插入排序。<br>选择一个增量序列a1,a2,a3…,an，其中ai大于ai-1，且an = 1，按照增量序列个数k进行k趟排序。<br>每趟排序，根据对应的增量 ai，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>\n<h4 id=\"代码（保留疑问）\"><a href=\"#代码（保留疑问）\" class=\"headerlink\" title=\"代码（保留疑问）\"></a>代码（保留疑问）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function shellSort(arr) &#123;</span><br><span class=\"line\">    var len = arr.length,</span><br><span class=\"line\">        temp,</span><br><span class=\"line\">        gap = 1;</span><br><span class=\"line\">    while(gap &lt; len/3) &#123;          //动态定义间隔序列</span><br><span class=\"line\">        gap = gap*3+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123;</span><br><span class=\"line\">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            temp = arr[i];</span><br><span class=\"line\">            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class=\"line\">                arr[j+gap] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j+gap] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><h4 id=\"时间复杂度-3\"><a href=\"#时间复杂度-3\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>不受输入数据的影响 时间复杂度始终都是o(nlog n)  但是需要额外的内存空间</p>\n<h4 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>采用分治法，把大化小，把已有序的子序列合并，进行排序，再得到有序的序列。循环递归得到完整的有序序列。<br>具体：</p>\n<ul>\n<li>把长度为n的输入序列分成两个长度为n/2的子序列； </li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n<li>不断的递归以上的步骤，就可以得到完整的有序序列</li>\n</ul>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class=\"line\">    var len = arr.length;</span><br><span class=\"line\">    if(len &lt; 2) &#123;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var middle = Math.floor(len / 2),</span><br><span class=\"line\">        left = arr.slice(0, middle),</span><br><span class=\"line\">        right = arr.slice(middle);</span><br><span class=\"line\">    return merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function merge(left, right)//排序函数</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = [];</span><br><span class=\"line\">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class=\"line\">        if (left[0] &lt;= right[0]) &#123;</span><br><span class=\"line\">            result.push(left.shift());</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result.push(right.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (left.length)</span><br><span class=\"line\">        result.push(left.shift());</span><br><span class=\"line\"></span><br><span class=\"line\">    while (right.length)</span><br><span class=\"line\">        result.push(right.shift());</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><h4 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h4><p>用数组实现的二叉树<br><strong>属性</strong><br>决定了树中节点的位置<br>最大堆：父节点的值比每一个子节点的大<br>最小堆：父节点的值比每一个子节点的小<br><strong>操作</strong><br>插入：插入的元素放到数组的尾部，再进行位置交换修复堆，元素上升或者下移。<br>删除：删除元素，并且将数组的最后一个元素位置换到删除元素的位置，再进行位置交换修复堆，元素上升或者下移。</p>\n<h4 id=\"时间复杂度-4\"><a href=\"#时间复杂度-4\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>o(nlogn)</p>\n<h4 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>利用数据结构堆的性质，把排序序列构建为堆，并且满足堆的性质。<br>具体：</p>\n<ul>\n<li>将待排序列构建成最大顶堆，该堆为无序的。</li>\n<li>将堆顶的元素a[0]和最后一个元素a[n]进行交换，得到无序区a[0]…a[n-1]和有序区a[n]</li>\n<li>不断的重复这项步骤，就可以得到一个有序序列</li>\n</ul>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*方法说明：堆排序</span><br><span class=\"line\">@param  array 待排序数组*/</span><br><span class=\"line\">function heapSort(array) &#123;</span><br><span class=\"line\">    //建堆</span><br><span class=\"line\">    var heapSize = array.length, temp;</span><br><span class=\"line\">    for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">        heapify(array, i, heapSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //堆排序</span><br><span class=\"line\">    //交换array[0]和array[n]，且进行排序</span><br><span class=\"line\">    for (var j = heapSize - 1; j &gt;= 1; j--) &#123;</span><br><span class=\"line\">        temp = array[0];</span><br><span class=\"line\">        array[0] = array[j];</span><br><span class=\"line\">        array[j] = temp;</span><br><span class=\"line\">        heapify(array, 0, --heapSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*方法说明：维护堆的性质</span><br><span class=\"line\">@param  arr 数组</span><br><span class=\"line\">@param  x   数组下标</span><br><span class=\"line\">@param  len 堆大小*/</span><br><span class=\"line\">function heapify(arr, x, len) &#123;</span><br><span class=\"line\">    var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp</span><br><span class=\"line\">    if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class=\"line\">        largest = l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class=\"line\">        largest = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //当不满足父节点大于（小于）子节点时，进行上移或者下移</span><br><span class=\"line\">    if (largest != x) &#123;</span><br><span class=\"line\">        temp = arr[x];</span><br><span class=\"line\">        arr[x] = arr[largest];</span><br><span class=\"line\">        arr[largest] = temp;</span><br><span class=\"line\">        heapify(arr, largest, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><h4 id=\"时间复杂度-5\"><a href=\"#时间复杂度-5\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>o(n+k) 稳定 需要一个额外的数据空间</p>\n<h4 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>把输入的数据值转化为键存储在额外开辟的数组空间中。</p>\n<ul>\n<li>找出待排数组中最大和最小的元素</li>\n<li>统计数组中每个值为 i 的元素的出现次数，存入数组 c 的第 i 项</li>\n<li>对所有计数累加（此步骤是算出每个元素的首个元素应该存在的位置）</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>\n</ul>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function countingSort(array) &#123;</span><br><span class=\"line\">    var len = array.length,</span><br><span class=\"line\">        B = [],</span><br><span class=\"line\">        C = [],</span><br><span class=\"line\">        min = max = array[0];</span><br><span class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    //比较得出最大最小元素</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;//对元素进行计数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var j = min; j &lt; max; j++) &#123;</span><br><span class=\"line\">        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);//对计数进行累加</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var k = len - 1; k &gt;= 0; k--) &#123;</span><br><span class=\"line\">        B[C[array[k]] - 1] = array[k];</span><br><span class=\"line\">        C[array[k]]--;//已经插入进去，则值减一</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return B;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><h4 id=\"时间复杂度-6\"><a href=\"#时间复杂度-6\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>最佳情况：T(n) = O(n+k)<br>最差情况：T(n) = O(n+k)<br>平均情况：T(n) = O(n2)<br>桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>\n<h4 id=\"思路-6\"><a href=\"#思路-6\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>把数据分到有限的桶中，每个桶再分别排序</p>\n<ul>\n<li>设置一个定量的数组当作空桶</li>\n<li>找出排序序列的最大最小值，用最大值减去最小值加一除以空桶的长度得出每个空桶中的数据范围。</li>\n<li>对每个不是空的桶进行排序</li>\n<li>拼接这些桶</li>\n</ul>\n<h4 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bucketSort(array, num) &#123;</span><br><span class=\"line\">    if (array.length &lt;= 1) &#123;</span><br><span class=\"line\">        return array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var len = array.length, buckets = [], result = [], min = max = array[0], regex = &apos;/^[1-9]+[0-9]*$/&apos;, space, n = 0;</span><br><span class=\"line\">    num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10);</span><br><span class=\"line\">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class=\"line\">        min = min &lt;= array[i] ? min : array[i];</span><br><span class=\"line\">        max = max &gt;= array[i] ? max : array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space = (max - min + 1) / num;</span><br><span class=\"line\">    for (var j = 0; j &lt; len; j++) &#123;</span><br><span class=\"line\">        var index = Math.floor((array[j] - min) / space);//算出该数据在哪个范围内，决定放在哪个桶中。</span><br><span class=\"line\">        if (buckets[index]) &#123;   //  非空桶，插入排序</span><br><span class=\"line\">            var k = buckets[index].length - 1;</span><br><span class=\"line\">            while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class=\"line\">                buckets[index][k + 1] = buckets[index][k];</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buckets[index][k + 1] = array[j];</span><br><span class=\"line\">        &#125; else &#123;    //空桶，初始化</span><br><span class=\"line\">            buckets[index] = [];</span><br><span class=\"line\">            buckets[index].push(array[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (n &lt; num) &#123;</span><br><span class=\"line\">        result = result.concat(buckets[n]);</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附上参考文章：<br><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8#heading-0\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/57dcd394a22b9d00610c5ec8#heading-0</a></p>\n","next":{"title":"关于动态规划的二三事儿","slug":"关于动态规划的二三事儿"},"link":"http://yoursite.com/post/js 基本算法总结/","toc":[{"title":"排序","id":"排序","index":"1","children":[{"title":"快速排序","id":"快速排序","index":"1.1"},{"title":"选择排序","id":"选择排序","index":"1.2","children":[{"title":"时间复杂度","id":"时间复杂度","index":"1.2.1"},{"title":"思路","id":"思路","index":"1.2.2"},{"title":"代码实现","id":"代码实现","index":"1.2.3"}]},{"title":"插入排序","id":"插入排序","index":"1.3","children":[{"title":"时间复杂度","id":"时间复杂度-1","index":"1.3.1"},{"title":"思路","id":"思路-1","index":"1.3.2"},{"title":"代码","id":"代码","index":"1.3.3"},{"title":"二分查找","id":"二分查找","index":"1.3.4"}]},{"title":"希尔排序","id":"希尔排序","index":"1.4","children":[{"title":"时间复杂度","id":"时间复杂度-2","index":"1.4.1"},{"title":"思路","id":"思路-2","index":"1.4.2"},{"title":"代码（保留疑问）","id":"代码（保留疑问）","index":"1.4.3"}]},{"title":"归并排序","id":"归并排序","index":"1.5","children":[{"title":"时间复杂度","id":"时间复杂度-3","index":"1.5.1"},{"title":"思路","id":"思路-3","index":"1.5.2"},{"title":"代码","id":"代码-1","index":"1.5.3"}]},{"title":"堆排序","id":"堆排序","index":"1.6","children":[{"title":"堆","id":"堆","index":"1.6.1"},{"title":"时间复杂度","id":"时间复杂度-4","index":"1.6.2"},{"title":"思路","id":"思路-4","index":"1.6.3"},{"title":"代码","id":"代码-2","index":"1.6.4"}]},{"title":"计数排序","id":"计数排序","index":"1.7","children":[{"title":"时间复杂度","id":"时间复杂度-5","index":"1.7.1"},{"title":"思路","id":"思路-5","index":"1.7.2"},{"title":"代码","id":"代码-3","index":"1.7.3"}]},{"title":"桶排序","id":"桶排序","index":"1.8","children":[{"title":"时间复杂度","id":"时间复杂度-6","index":"1.8.1"},{"title":"思路","id":"思路-6","index":"1.8.2"},{"title":"代码","id":"代码-4","index":"1.8.3"}]}]}],"copyright":{"custom":"飞过人间的无常 才懂爱才是宝藏"}}