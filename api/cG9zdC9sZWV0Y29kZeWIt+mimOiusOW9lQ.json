{"title":"leetcode刷题记录","date":"2018-10-22T14:13:02.996Z","slug":"leetcode刷题记录","tags":["数据结构"],"categories":["数据结构"],"updated":"2019-03-22T10:13:15.183Z","content":"<h2 id=\"10-22\"><a href=\"#10-22\" class=\"headerlink\" title=\"10.22\"></a>10.22</h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><blockquote>\n<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var twoSum = function(nums, target) &#123;</span><br><span class=\"line\">    for(i=0;i&lt;nums.length;i++)</span><br><span class=\"line\">        for(j=i+1;j&lt;nums.length;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                var a = nums[i]+nums[j];</span><br><span class=\"line\">                if(a == target)&#123;</span><br><span class=\"line\">                    return [i,j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-18\"><a href=\"#11-18\" class=\"headerlink\" title=\"11.18\"></a>11.18</h2><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><blockquote>\n<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>\n</blockquote>\n<blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>\n</blockquote>\n<blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n</blockquote>\n<blockquote>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n</blockquote>\n<h4 id=\"踩的坑：\"><a href=\"#踩的坑：\" class=\"headerlink\" title=\"踩的坑：\"></a>踩的坑：</h4><p>现在来说说是什么致使我竟然写这个题写了两个多小时..</p>\n<ol>\n<li>题目意思没有理解清楚，第一次以为只有4 9 40 90 400 900才是这样表示，没有想到可以穿插在数中。第二次以为只能放在尾数中。（直接导致了我白写了3-4遍 心情就很sad）</li>\n<li>没有反应过来return表示函数的结束。</li>\n<li>还有很多没有考虑全面的…</li>\n</ol>\n<h4 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h4><ol>\n<li>切割罗马数组为数组。</li>\n<li>暴力for循环遍历这个数据，并且做不同情况的判断。</li>\n<li>然后完了..</li>\n</ol>\n<h4 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h4><pre><code>var romanToInt = function(str){\n    var a = str.split(&quot;&quot;);\n    var b = str.length;\n    var count = new Number ;\n    for (var i = 0; i &lt;= a.length - 1; i++) {\n        if(a[i] === &quot;I&quot;&amp;&amp; a[i+1] !== &quot;V&quot;&amp;&amp; a[i+1] !== &quot;X&quot;)\n            {\n                count += 1;\n            }\n            else if ((a[i] === &quot;I&quot;&amp;&amp;a[i+1] == &quot;V&quot;)||(a[i] === &quot;I&quot;&amp;&amp;a[i+1] == &quot;X&quot;)) {\n                count -= 1;\n            };\n        if (a[i] === &quot;V&quot;) {count += 5};\n        if (a[i] === &quot;X&quot;&amp;&amp; a[i+1] !== &quot;L&quot;&amp;&amp; a[i+1] !== &quot;C&quot;)\n            {\n                count += 10;\n            }\n            else if ((a[i] === &quot;X&quot;&amp;&amp;a[i+1] == &quot;L&quot;)||(a[i] === &quot;X&quot;&amp;&amp;a[i+1] == &quot;C&quot;)) {\n                count -= 10;\n            };\n        if (a[i] === &quot;L&quot;) {\n            count += 50;\n        };\n        if(a[i] === &quot;C&quot;&amp;&amp; a[i+1] !== &quot;D&quot;&amp;&amp; a[i+1] !== &quot;M&quot;)\n            {\n                count += 100;\n            }\n            else if ((a[i] === &quot;C&quot;&amp;&amp;a[i+1] == &quot;D&quot;)||(a[i] === &quot;C&quot;&amp;&amp;a[i+1] == &quot;M&quot;)) {\n                count -= 100;\n            };\n        if (a[i] === &quot;D&quot;) {count += 500};\n        if (a[i] === &quot;M&quot;) {count += 1000};\n    }\n    return count;\n}\n</code></pre><h2 id=\"2018-12-04丑数\"><a href=\"#2018-12-04丑数\" class=\"headerlink\" title=\"2018.12.04丑数\"></a>2018.12.04丑数</h2><h3 id=\"题目-2\"><a href=\"#题目-2\" class=\"headerlink\" title=\"题目\"></a>题目</h3><blockquote>\n<p>编写一个程序判断给定的数是否为丑数。</p>\n</blockquote>\n<blockquote>\n<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:</p>\n</blockquote>\n<blockquote>\n<p>输入: 6<br>输出: true<br>解释: 6 = 2 × 3<br>示例 2:</p>\n</blockquote>\n<blockquote>\n<p>输入: 8<br>输出: true<br>解释: 8 = 2 × 2 × 2<br>示例 3:</p>\n</blockquote>\n<blockquote>\n<p>输入: 14<br>输出: false<br>解释: 14 不是丑数，因为它包含了另外一个质因数 7。<br>说明：</p>\n</blockquote>\n<blockquote>\n<p>1 是丑数。<br>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。</p>\n</blockquote>\n<h3 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h3><ul>\n<li><p>本题只需要将输入数一直除以质因数，如果商为整数则继续除，为小数则说明不是丑数，如果最终结果为1，则为丑数。</p>\n</li>\n<li><p>还是暴力的使用了for循环..判断条件为输入值是否为整数<br>判断是否为小数的方法：<strong>String(num).indexOf(“.”)</strong><br>当返回值为-1时，表示该数为整数</p>\n</li>\n<li><p>当数除以2、3、5不为小数时，会把商赋值给原来的数。继续for循环，直到数变为1时，返回true。<br>当任意一次的商为小数时，返回false。</p>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre><code>var isUgly = function(num) {\n    if(num&gt;0){\n        for (;String(num).indexOf(&quot;.&quot;) === -1;) {\n            if (String(num/2).indexOf(&quot;.&quot;) === -1) {\n                num = num/2;\n            }\n            else if(String(num/3).indexOf(&quot;.&quot;) === -1){\n                num = num/3;\n            }\n            else if (String(num/5).indexOf(&quot;.&quot;) === -1) {\n                num = num/5;\n            }\n            else if(num === 1){\n                return true;\n            }\n            else{\n                return false;\n            }\n            if (num === 1) {\n                return true;\n            }\n        }\n    }\n    else{\n        return false;\n    }\n};\n</code></pre><h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>没有考虑到 1</li>\n<li>直接在if中的下一级判断是否等于1 导致一直返回false</li>\n</ul>\n<p><code>if (String(num/2).indexOf(&quot;.&quot;) === -1) {\n        num = num/2;\n        if(num === 1)\n            return true;\n        }\n    }</code></p>\n<h2 id=\"路径总和\"><a href=\"#路径总和\" class=\"headerlink\" title=\"路径总和\"></a>路径总和</h2><p>2019.3.22  二叉树</p>\n<h3 id=\"题目-3\"><a href=\"#题目-3\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>\n<pre><code>      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\      \\\n7    2      1\n</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>\n<h3 id=\"算法思路-1\"><a href=\"#算法思路-1\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h3><ol>\n<li>没有根节点时返回false</li>\n<li>关键词 <strong>根节点 叶子节点</strong> 采用递归的方式遍历整个二叉树，每次遍历目标和都减去当前节点的值。</li>\n<li>当不存在左右节点的时候，判断目标和是否已经为当前节点的值了，如果为当前节点值，则说明有路径节点值相加等于目标和，返回true。否则返回false。</li>\n</ol>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @param &#123;number&#125; sum</span><br><span class=\"line\"> * @return &#123;boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var hasPathSum = function(root, sum) &#123;</span><br><span class=\"line\">    if(!root)&#123;return false&#125;</span><br><span class=\"line\">    if(!root.right &amp;&amp; !root.left)&#123;</span><br><span class=\"line\">        return sum === root.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"路径总和II\"><a href=\"#路径总和II\" class=\"headerlink\" title=\"路径总和II\"></a>路径总和II</h2><h3 id=\"题目-4\"><a href=\"#题目-4\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<br>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>\n<pre><code>      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\    / \\\n7    2  5   1\n</code></pre><p>返回:</p>\n<pre><code>[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n</code></pre><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>看完题目便想到需要增加两个变量，arr满足要求的数组组成的数组，参数path为遍历的路径。这是典型的DFS。</li>\n<li>采用树的深度优先搜索法，进行递归查找。存在左右节点的时候则分别进行遍历，遍历时把对应的节点值放入path中，并且sum减去当前节点的值。</li>\n<li>当一条路径遍历结束且sum已经被减为0，则说明当前路径m满足题目要求，则push到arr中，最后全部路径遍历完成后，返回arr。</li>\n</ol>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * function TreeNode(val) &#123;</span><br><span class=\"line\"> *     this.val = val;</span><br><span class=\"line\"> *     this.left = this.right = null;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;TreeNode&#125; root</span><br><span class=\"line\"> * @param &#123;number&#125; sum</span><br><span class=\"line\"> * @return &#123;number[][]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">var pathSum = function(root, sum) &#123;</span><br><span class=\"line\">    var arr = []</span><br><span class=\"line\">    if(root == null)&#123;</span><br><span class=\"line\">        return arr</span><br><span class=\"line\">    &#125; //节点值为空时，返回arr</span><br><span class=\"line\">    pathTree(root,sum-root.val,[root.val])</span><br><span class=\"line\">    return arr</span><br><span class=\"line\">    function pathTree(node,sum,path)&#123;</span><br><span class=\"line\">        if(!node.left &amp;&amp; !node.right)&#123;</span><br><span class=\"line\">            if(sum === 0)&#123;</span><br><span class=\"line\">                arr.push(path)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node.right &amp;&amp; pathTree(node.right,sum - node.right.val,path.concat(node.right.val))</span><br><span class=\"line\">        node.left &amp;&amp; pathTree(node.left,sum - node.left.val,path.concat(node.left.val))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","prev":{"title":"MongoDB学习笔记","slug":"MongoDB基本知识"},"next":{"title":"win10界面美化","slug":"win10界面美化"},"link":"http://yoursite.com/post/leetcode刷题记录/","toc":[{"title":"10.22","id":"10-22","index":"1","children":[{"title":"题目","id":"题目","index":"1.1"}]},{"title":"11.18","id":"11-18","index":"2","children":[{"title":"题目","id":"题目-1","index":"2.1","children":[{"title":"踩的坑：","id":"踩的坑：","index":"2.1.1"},{"title":"解题思路：","id":"解题思路：","index":"2.1.2"},{"title":"代码：","id":"代码：","index":"2.1.3"}]}]},{"title":"2018.12.04丑数","id":"2018-12-04丑数","index":"3","children":[{"title":"题目","id":"题目-2","index":"3.1"},{"title":"算法思路","id":"算法思路","index":"3.2"},{"title":"代码","id":"代码","index":"3.3"},{"title":"遇到的问题","id":"遇到的问题","index":"3.4"}]},{"title":"路径总和","id":"路径总和","index":"4","children":[{"title":"题目","id":"题目-3","index":"4.1"},{"title":"算法思路","id":"算法思路-1","index":"4.2"},{"title":"代码","id":"代码-1","index":"4.3"}]},{"title":"路径总和II","id":"路径总和II","index":"5","children":[{"title":"题目","id":"题目-4","index":"5.1"},{"title":"思路","id":"思路","index":"5.2"},{"title":"代码","id":"代码-2","index":"5.3"}]}],"copyright":{"custom":"飞过人间的无常 才懂爱才是宝藏"}}